---
title: 【C++】实现一个可动态调整带优先级的线程
date: 2025-01-27
tags:
  - C++
  - 线程池
excerpt: 支持动态增加删除线程，支持优先级设置
---

这次改变以前的写博客风格，我会先将我遇到的问题，代码中需要注意的点写出来，然后列出全部代码供查看。
我的代码会在每个函数前面标出函数作用，同时在一些关键地方保留注释，以便于理解。
读这部分内容，可能需要至少知道基础的线程池的实现，所以如果有不清楚的，可以先去看我的上一篇博客。
我尽可能的写得详细，以求读者跟上我的思路，如果再详细，就会显得啰嗦了。

# 要点

**代码概览**
这次的线程池，考虑到需要设置优先级，很容易地就想到了优先队列。在这次代码中，我封装了一个安全的优先队列，重构了队列的入队出队操作，在内部封装了锁、等待和唤醒功能。
队列内部存储的元素，除了std::function以外，还需要存储一个代表优先级的东西。这里可以设置一个结构体，但我选择了类，因为我对类更熟悉。我构造了一个类Event，作为队列内存储的元素。内部实现了移动语义。

**优先队列的构建**
优先队列的模板参数中，需要指定这样三个内容：存储类型，底层容器，比较器。
其中，存储类型我们已经说过了。是Event。
底层容器，优先队列不是一个纯粹的容器，它的底层容器一般是deque或者vector实现。
比较器，是用来判断它的优先级的，要求我们提供一个比较函数。我们存储了Event，在Event类内部重载小于号也可以。

**优先队列的缺陷**
优先队列没有front函数，取而代之的是一个top函数。这个函数返回一个const类型的引用。这导致我们无法将它从队列中“移动”出来，只能拷贝。
但是我们存储的是Event，内部封装有std::function，一般情况下我们说尽量不要拷贝它。如果说它封装了一个lambda表达式，而表达式捕获了太多东西，可能造成很大开销。
其实我们也可以强行将它去掉const，然后强行移动出来。但是标准库要求禁止这么做，否则会损坏堆。

**优先队列的缺陷解决方案——存储智能指针**
最后我选择在队列中存储shared型智能指针，这样无论怎么拷贝，都不会有太大问题了。
只是，在存储和读取以及使用时，需要注意一下。
另外，请注意，如果之前在Event类内部重载小于号，这里需要重设一个比较器，不能再沿用之前的。

**线程池类的构建**
我们虽然封装了队列，但实际上队列的存取，还是在线程池类内调用的，这样我们便可以轻松获取队列存储细节。
线程池类的成员中，我设置了一系列状态，用来获取当前队列内的任务数，当前创建的线程数，当前正在执行任务的线程数。在维护这些状态过程中，要注意哪里要增加，哪里要减少。
除此之外，也维护了最小最大允许的线程池，并且在构造函数中做了一些处理，如果需要修改可以轻松修改。
为了避免vector频繁扩容，我们一开始就根据最大允许的线程池数量给vector分配容量。

**线程池动态创建**
在以前的代码中，我们直接在构造函数中循环固定次数，然后每次循环构建一条线程。
这部分代码完全可以抽象出来，成为一个单独的函数。每次循环调用这个函数，就在vector中创建一条线程。
在这里，我们设置一个addpool函数，循环调用它可以在vector中调用一次emplace_back，构造一个线程。此处它对vector操作了，需要获取锁。
这里，在vector中构造了一个线程，相对于当前线程来说，是一个独立的线程，把它想象成一个子线程，因此不会受到这里的锁管理，也不会影响这里的锁释放。

**添加任务函数**
这里插入任务时，我们需要同时要求一个优先级函数，如果不提供此参数，则默认为1（最小的优先级）。
同时我们要求优先级应该是正数。但若是这里强制size_t，可能会造成超出int范围之类的情况。考虑到我们的线程池使用者应该是一个开发人员，他应该负责注意这一点，这里就只写了注释，做个君子协定。
（为什么要求是正数？我们后面会讲）
之后，像之前一样，将用户传入的函数和参数经过完美转发和封装，最后成为一个没有返回值也没有参数的std::function。
然后将它构建到Event中，以智能指针的方式存储入队列。

**取出任务**
我们在队列中封装了取出任务操作，而且有了锁，这里直接调用函数就行了。
我们取到的任务，该如何拿出来呢？这里不一定非得返回。否则的话，我们的出队函数返回值必须是一个Event智能指针，这显得格外麻烦，如果有其他情况，还得费劲构造返回值。
所以我们在while外面，创建一个临时的空的智能指针，将它的引用传入函数，取值出来。
这个临时智能指针的生命周期，将会随着这个线程一直存在，而因为它在while循环外，又使得它不会反复重新创建。

**智能指针内对象的生命周期**
到这里，我们的智能指针内存储的对象的生命周期，应该已经清晰了。
不过我还是可以总结一下：
（1）在线程池类添加任务函数中，我们构建了智能指针，并将它存入队列。此时队列持有持久化智能指针。
（2）线程通过临时智能指针，从队列中取出对象，随后队列删除智能指针，对象交给临时智能指针管理。
（3）临时智能指针执行任务，直到下次被新的任务取代，重新赋值，删除对象。

**手动关闭线程池**
我提供了shutdown函数，可以调用这个函数手动关闭线程。
当调用此函数时，会发出stop信号，并调用队列函数，唤醒所有线程。在队列的出队函数中，妥善处理删除逻辑，返回false。
线程从队列中取值，却得到false，就会知道线程池要退出了，直接return。
shutdown函数中，对所有线程join，确保它们都运行完毕。
如果用户忘了调用它，也可以在析构函数中调用，避免出错。

**线程动态增加**
前面已经说过了，我们直接调用addpool函数即可，每调用一次，就可以创建一条新的线程，只要注意好边界和锁即可。

**线程动态减少——思考**
这是本文最难的点。
我们都知道，为了避免扩容，我们给线程池预设了容量，如果说我们只停止了一条线程，而没有删除它。那么它在vector中仍然占有位置。如果再动态调整让它增加，就要扩容了。
所以这里要解决两个问题，1，如何停止一条线程,2，如何删除它。

**动态调整之——如何停止线程**
想象一下，一般来说我们调用这个函数，一定是线程池比较充裕，队列中也没有任务。此时，一条条线程就像一个个正在等待的工人，当队列中有了新任务，便会随机唤醒一个工人，然后工人从中拿到任务。
所以我们需要先通过等待。此时我们的等待满足条件已经有两个了，怎么办？难道再增加新的判断条件吗？这样会让逻辑变复杂。
这就提到我们前面说的了。我们新建一个函数delpool，在这个函数中，构造一个特殊的Event，存入队列中。这个Event的事件是一个空lambda表达式，而优先级是-1。
当工人拿到任务后，先检查优先级，如果优先级不是-1，则当正常任务处理。如果优先级是-1，他就会知道这是删除自己的表现。

**动态调整之——如何删除线程——初步思考，detach**
那怎么删除自己呢？我们不能让当前线程自己删除自己，这会导致死锁或者未定义。我们会在删除之前先join，这就更加死锁了。
思来想去，我们只能让这条线程以外的线程去删除它。
我们都知道，线程有着唯一标识，也就是它的id。我们可以获取它的id，然后启动一个临时小线程，让这条线程detach运行。这样，它被删除就不会影响detach运行了。
在detach中，我们通过遍历vector找到我们要找的线程id，然后安全join并删除。

如果说你觉得这样find太麻烦了，你也可以维护一个新的vector或者map，以线程id为键，快速获取你要找的下标（我这里没有用这样的方法）。

**动态调整之——如何删除线程——再次思考**
但是这样依然有问题。
detach意味着我们无法管理到这条线程了。当我们调用shutdown时，如果说此时正好有一条线程要删除，两者会重复操作，导致其中某个步骤拿到已被销毁的线程，出现未定义。
我们当然可以在detach中先判断stop信号，但是如果刚好卡在发出信号前进入stop，这里就显得拖泥带水。虽然极限，但这么个因素的存在显得不够完美。
而且，detach本身不是一个安分因素，不受到我们掌控，终究还是选择尽量不用它。

思来想去，我直接有样学样。你需要一个线程，我就给你一个独立线程。我是怎么有样学样的？往下看就知道，这种方法相当于基于线程池方法的扩展，非常易于理解。
我们直接在构造之初，创建一个特殊线程，这个线程内部，也运行着一个无限循环，专门负责删除那些“待删除线程”。
然后，创建一个容器，专门用来存储“待删除线程的id”。
然后，我们用wait卡住线程，检测容器内部是否有着id。如果没有，就wait。
如果容器中存入了wait，我们就唤醒它，让它执行删除。
怎么样，是不是和线程池的思路一模一样？

在shotdown中，我们先发出stop信号。当进入删除函数delpool时，先检查是否stop，如果stop，就不再构建特殊事件了。
在shotdown中，我们唤醒所有线程，也唤醒这个特殊线程。这时候，我们可以让这两个线程都安全join完毕，再退出事件了。
而经过这样join，shotdown也不会和它冲突了。

